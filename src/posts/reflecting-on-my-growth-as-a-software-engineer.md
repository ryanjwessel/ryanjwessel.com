---
title: 'Reflecting On My Growth As A Software Engineer'
date: '2020-04-05T19:30:00-05:00'
bannerImgSrc: 'https://images.unsplash.com/photo-1518241353330-0f7941c2d9b5?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1850&q=80'
bannerImgAlt: 'Small island with a yellow tree in a calm pond'
---

I remember writing HTML and CSS to customize my MySpace profile back in 2006, an
experience I'm sure many late-stage Millennials share with me. There was no
end-goal. I was just tinkering with a reckless disregard for the
cringe-worthiness that my middle school digital persona produced.

After that, I didn't touch anything code-related until 2010 when my high school
offered a Programming elective in our computer lab. There, we learned some Flash
development. I remember trying to recreate Galaga, which has always been my
favorite arcade game. I designed a few sprites, and maybe got the mechanics of
moving and firing the ship working.

But, it wasn't until I started to take Information Systems courses in 2014 that
I realized a career in software would be a good fit for me. In fact, I loved the
idea of it. Designing and building solutions for real problems at scale. Working
in dynamic, fast-paced environments that would keep me mentally stimulated. It
was the first time I actually had an idea of what I could be doing after I
graduate college.

Reflecting on the six years since I had that realization, I can see how much I
have learned over that time. However, there are many cases where I remember
feeling completely overwhelmed at the sheer volume of topics that I _could_ be
learning, and thinking that I am not actually good at what I do.

I am going to write about my journey into software over the past half-decade,
and reflect on concepts and technologies that I familiarized myself with over
that time. My hopeful outcome for those reading this is two-fold.

1. I hope that you see that it is okay to not know everything right now, and
   that it takes time to learn anything. There are so many subject matter
   experts, and so much content available on dozens of channels like Medium and
   YouTube. It is easy to see all of that and feel you are too far behind to
   even get started. It is okay to start from knowing nothing, and over time you
   will get better!

1. I hope this inspires you to reflect on progress you have made in areas where
   you are overly critical with your self. It is easy to lose sight of the
   progress you have made when you are always looking forward. There is a
   delicate balance to strike between being content with where you are and
   wanting more from yourself. Each of us has their own point on that scale, and
   it changes all of the time.

## Fairfield University - Spring of 2014

Prior to my junior year of college, I had no programming experience at all
outside of my MySpace and Flash Galaga experiences. There were two courses in
the Information Systems program that taught me technical skills, while the rest
were more focused on project management.

The first course was Fundamentals of Web Design, where we learned the basics of
HTML and CSS. We learned about the importance of semantic elements like the
`<footer>` and `<header>` tags, and the intricacies of CSS positioning and
floating. We also spent time learning non-technical skills like wire-framing,
and building a sitemap.

The second course was Database Systems, where we learned about SQL and databases
in general. We spent some time on the topic of normalization, and the different
levels a database can be normalized. Much of this went over my head at the time,
but I did my best to understand it. We also learned about data modeling, and how
to create Entity-Relationship Models. This part was a little easier for me to
grasp because we had to create our own Entity-Relationship Models for a project
of our choosing. Having to reason about a real example, instead of focusing on
theory, helped me to understand it.

That was the complete extent of the "programming" skills I learned about in
class. Others were focused on project management, but some of our projects did
involve building WordPress websites for local non-profits. My curiosity in this
field was piqued, but I had to learn more outside of school to make further
progress.

## Truebadore - Summer of 2014

During my summer break, I got an unpaid internship through Fairfield's Career
Center in Bridgeport, Connecticut. Truebadore's business was focused on
gamifying experiences in the healthcare space, and the owner, Brian, already had
a handful of clients. He needed some help building his brand website, and in
exchange he taught me some of what he knew about software development.

I met up with Brian once a week at a co-working space, and that was an exciting
experience. I did not know this type of place existed, and I loved being able to
talk with people from other small businesses.

Truebadore already had a logo and a website, but it was a very plain design. He
wanted something a little more fun that reflected the joy of gaming at the heart
of his brand. It was already built in WordPress, and he showed me how to work
with the Git repository where the version history was maintained. I had never
worked with a version control system before, and he wanted me to commit my
changes so that we could review them each week.

I found a WordPress theme that provided us with a nice layout, and we iterated
on changes to the sitemap as I built some of the pages. Also, we gradually came
to the conclusion to alter his brand design from black and red to a more playful
orange and light blue. I redesigned his branding materials using Adobe
Illustrator, and wrote the CSS so the theme would reflect this new design.

Brian made it a great experience to work with him as a "client", but he also was
patient and helpful in answering my questions about Git and best practices for
building websites.

The site can still be found today at [truebadore.com](http://truebadore.com),
but I am not sure if he is still actively running the business.

## The Fairfield Mirror - Winter of 2014

This is a brief point, but one that I like to reminisce on. Mainly, because this
site is still actively used by the student writers at The Fairfield Mirror, the
student newspaper at Fairfield University.

This was my first experience working with a “real” client, as I was paid a few
hundred dollars to rebuild their website so it was more mobile-friendly and
better designed. It was a good chance to build the soft skills of communication
during a project. I had to ensure the categorization and tagging of posts
aligned with their editorial desires, and they needed to understand how to set
articles up so they worked in this new theme.

Technically, I had to learn how to migrate my work from local development to
their server, and I had to back up their existing site so I could revert
everything if I messed anything up. Also, I had to ensure all of their post
history was retained and displaying correctly in the new setup.

All-in-all, it went pretty smoothly, and it was a great experience for me over a
winter break.

## The A100 Apprenticeship Program - First Half of 2015

At this point I was one semester away from graduating, and I was just starting
to think of building software as a potential career for me. My professor for
most of my Information Systems courses, Chris Huntley, recommended that I look
into the A100 program. It was an apprenticeship program sponsored by grants from
the state of Connecticut to build out a stronger tech community locally. I was
tested on HTML, CSS, and Javascript, and I had enough of a baseline
understanding to be accepted into the program.

The program consisted of weekly meet-ups where we would learn about a topic from
someone that works in the field. That would cover areas like Git best practices
and advanced commands, the Agile methodology in-practice, manipulating the DOM
with Javascript, and others. We would also work on personal projects to demo to
the group every couple of weeks.

After a month or two of this learning curriculum, we jumped into building a
Minimum Viable Product for a startup that had contracted the A100 team to build
to pitch to investors. This was built using Meteor, a Javascript framework that
allowed us to build client-side and server-side code all in Javascript. Our
database was built using MongoDB, which was my first exposure to a NoSQL
database. This was also my first experience designing a user interface for an
application, and actually dealing with DOM interactions from the user like
clicking buttons to submit or delete, and interacting with form fields. Applying
libraries like jQuery and Bootstrap made these tasks a lot simpler for my foray
into this type of work.

By the end of the program, I built another MVP for a separate client. We would
have to demo features at the end of each sprint which really helped to improve
my confidence in public speaking. These skills really helped me during my job
search after graduating, and eventually I was able to land my first role as a
Front End Web Developer.

## Synapse Group - Late 2015 to the Middle of 2018

Synapse is a multi-channel marketing company, which basically meant that it
takes in traffic from many different sources and directs them to various offers
they have hosted online. At the time, they were a subsidiary of Time Inc., so
most of those offers were selling magazine subscriptions. I know, not the most
exciting industry in the world, but I was really excited to work on a team with
more experienced developers and learn in a production environment.

### A/B Testing + Google Analytics

Given the nature of their business, there was a constant flow of new offers
being promoted and tests being run on existing offers. This was my first time
learning about A/B testing, and how it was used to optimize the performance of
e-commerce flows. All of the sites we released and tests we published were set
up to provide data to Google Analytics. That data was used to determine which
test variant “won”, and then it became the new “control” version of the site.

Google Analytics is an expansive platform, and over time I was able to update
our integration so that the quality and the quantity of our data was vastly
improved. I set up event tracking for specific test behaviors, tracking items in
cart as the user moved through the flow, and added custom dimensions to provide
additional data from the sources of our traffic.

Another thing Google Analytics did well was track the percentage of our traffic
that was coming from specific browsers. Since each user represented potential
revenue, we needed to ensure that all of our sites supported any browser version
that represented more than 1% of our overall traffic. At the time, this meant we
were supporting all browsers back to Internet Explorer 9. This meant we had QA
resources that had to test our sites on all of the supported browsers, and we
had to do our due diligence in making sure the major browsers were working as
expected. Over time, this improved as IE 10 and any older versions shrunk to an
insignificant portion of our traffic.

### Workflow Automation

Aside from our QA process, there were other workflows that took up a significant
portion of our time. One of them was updating the product lists that were used
on all live sites on a quarterly basis. For some reason, Synapse had a GUI that
managed the product lists in the database, and there was no API available to
dynamically update them. So, this meant the front end team (why?!) had to go
into each list and physically drag-and-drop the products in the order specified
by the publisher relations team. There were hundreds of lists, and each list had
anywhere between 20 and 50 products, so this process would take an entire week
of coordinated effort between 4 developers.

I pleaded my case for finding a way to automate this after the second quarterly
update, and fortunately was given the bandwidth to do so. I used a library
called Nightmare.js for headless browser automation, and figured out how to
import data from Google Sheets to define the product lists. It took 2-3 weeks to
get a complete run of the script working, so then I had to coordinate with the
other teams that were involved. Publisher relations had to start using Google
Sheets instead of Excel, and the Marketing team had to be able to review the
lists to ensure high-performing titles were being included at the top of the
page. After those steps, it was ready for handoff to our team.

When it was all said and done, this endeavor took 4-6 weeks to complete. But, it
took a process that consumed 80 hours of developer time (4 developers, 50% of a
40-hour workweek) down to a 5-minute script that ran in the background. After
this, I swore to find a means to automate any task that felt repetitive and
time-consuming.

### Migrating to React + The Impact of Mobile Page Load Speeds

Another inefficiency was the variety of technologies we were using for the
different channels we were supporting. They were built over the course of almost
a decade by different developers, so some were made using static HTML, CSS, and
Javascript, and others were made with tools like Gulp and EJS. Some were made
using Groovy Server Pages, which is a server-side view rendering library based
on Groovy, which is based on Java. Given that, there was a huge cognitive load
when switching between projects, and no consistency in the tools we were using.
It was around this time that my interest in React began.

Surprisingly, I found it more difficult to gain the bandwidth for converting our
projects to a consistent toolkit like React, Redux, and Webpack. Ironically, as
I grew within the organization it was increasingly important that my time be
spent on what the business “needed” me to do (more A/B testing) instead of the
inefficiencies I was identifying. Perhaps I needed to make a more compelling
case to key stakeholders, but I lacked that insight at the time.

In any case, eventually I did gain the bandwidth to take on this project. I made
a custom Webpack configuration, learned the intricacies of state management
using Redux, and painstakingly re-created the design and experience of the
Grails Server Pages application in React and Sass. Then, I had to integrate
Google Analytics as we had it before, and refactor the pixel code from our
channel partner to work in a single-page application context.

This undertaking took almost two months to be production-ready, and now we had
to release it into the wild. This was a major channel that had millions of
monthly unique visitors and represented a significant portion of company
revenue, so this was a sensitive release. We phased it so that we gradually
increased the percentage of traffic it was receiving over the next couple of
months. The results were surprising.

Granted, the phased rollout did reveal some bugs in the application, and
fortunately we were able to catch them before they would have caused losses in
revenue. But, what was most surprising about this release was that our
conversion rates had significantly improved. Like, in the realm of >20% increase
in conversion rates, and this represented a significant revenue gain that was
not expected from a technology change. What I found in my analysis was that we
went from mobile page load times that were approximately 8-10 seconds to less
than 1 second, and navigating between pages required no time at all now. Before,
each page in the flow would take at least 5 seconds on the 3G network speeds,
and now everything was instantaneous after that first second. There have been
many studies published on the impact of page load speed on bounce rates and
conversion rates, but I was genuinely surprised at the scope of the impact that
it had.

I had learned a lot in my time at Synapse, but in the end I was frustrated by
the resistance to change. So, I decided to look for something new in a more
technology-focused organization.

## PebblePost - Late 2018 to Today

PebblePost is an AdTech startup based out of Manhattan, and they were at the
forefront of the digital-to-direct-mail advertising channel. Effectively, brands
share website events and customer data with us. Then, we use that to link online
intent behaviors to a household, and mail postcards to the addresses that we
ranked as the best candidates. My role was focused on rebuilding their ad
management platform from the ground-up, and to formalize design and coding
standards as they continued to scale.

### Rebuilding the Platform + Formalizing Standards

In my first couple of months, I was primarily focused on stabilizing the
existing platform, and working with Product and the rest of the Dashboard team
in planning how we would approach the platform rebuild.

It was immediately clear that the existing project was difficult to work with
for users and for engineers. Plenty of the workflows had bugs that prevented
certain actions, and those were fixed by updating the database manually while we
solved that bug. It felt like each time one bug was addressed, two more took its
place. In my opinion, there were a couple of reasons behind this.

One, there were conflicting standards within the project. The Atomic Components
structure was partially applied. Some components did not separate data and
presentational concerns at all. The lack of consistent structure and
partially-applied separation of concerns meant that it was unclear whether your
changes would have an unintended impact on other parts of the application.

Second, there was a significant amount of dead code in the project. This
exacerbated the previously-mentioned problems, as there was so much unused code
that people were afraid to remove anything in fear of causing a breaking change.

Ultimately, the fear of making changes outside of addressing known bugs was a
bad place to be as a team. We had test coverage that was greater than 75%, but
it did nothing in terms of giving us confidence in releasing code.

My solution was to get everyone on the Dashboard team engaged in formalizing
some high-level standards for the project. It would entail a set of rules that
kept us consistent, but weren’t so restrictive that we couldn’t make progress.
We updated the new projects README to outline the expected project structure,
and we agreed to use Pull Requests as a medium to continue to drive this
discussion forward.

Over the next six months, we continued to refer back to these project standards,
and updated them when we all agreed to. This made this new project significantly
easier to work in, and as a result we launched the new platform with a much more
stable experience than before.

### TypeScript

One of the project standards we agreed to was to use TypeScript instead of plain
JavaScript for the rebuild. Static-typing was a new concept for me simply
because I have worked in the dynamically-typed world of plain Javascript for my
entire career. We decided to use it for the platform rebuild as many of our team
members had experience in statically-typed languages such as Java. So, my
initial experience was feeling slowed down by learning the nuances of
TypeScript. But, after a month or two of concerted effort I could easily see the
benefits throughout our project.

The expected data types were defined for all of the responses to our network
requests, and they mirrored the model defined in our back-end. This required
some extra effort to keep in-sync, but it was invaluable in always knowing what
data structures we were dealing with.

Our Redux store, reducers, and actions were all typed. This meant we always knew
we were providing the correct information when dispatching a request, or mapping
state to props.

Also, with `styled-components` we were able to define the theme object that our
`ThemeProvider` would make available to any styled component in the project.

The TypeScript support on VS Code is unparalleled since Microsoft maintains
TypeScript and VS Code, so you almost always will catch a bug in your code
before you even leave the editor once everything is typed. Shortening the
feedback loop to catching them in the editor as opposed to the compiler or
browser saves invaluable time for everyone on the team.

Last, and certainly not least, static-typing made the entire project
self-documenting. It became infinitely easier for engineers to jump across
different parts of the project because the type definitions clarified the
expected behaviors. Of course, it is still good to comment where it is useful,
but on-boarding and knowledge sharing became significantly easier once we were
all comfortable with TypeScript.

### Test Driven Development

Static-typing was only one piece of the testing equation that we needed to solve
for. Albert Orlando, a fellow engineer on the team, and myself became interested
in Kent C. Dodd's content surrounding testing in Javascript. We asked if
PebblePost would pay for his Testing Javascript course, and fortunately it was
approved! There was a clear need to improve our testing methodology on the
front-end because, as I mentioned earlier, we had >75% test coverage that was
not helping us deliver code with confidence.

By taking this course, the distinctions between static-typing, unit testing,
integration testing, and end-to-end testing became more clear to me. They all
comprised the overall “trophy”, and we were really only doing static-typing and
unit-testing. We needed to improve our integration testing approach first, and
then we could consider end-to-end testing.

[Here is a link](https://testingjavascript.com/) to the course if you are
interested in learning more.

### Integration Testing and Snapshots

Enzyme and snapshot testing improved our test coverage, but gave us little to no
increase in delivery confidence. The abstractions of Enzyme caused us to write
our components to fit our tests, rather than writing tests to validate the
components. And we were barely using Enzyme for integration tests as it was.

So, we began to remove snapshot tests where they were providing no value, and
replaced them with specific behavioral checks where appropriate. For example, if
a component receives a prop with a value of true, confirm an element is disabled
or enabled based on that behavior. These assertions were more valuable than
committing rendered HTML snapshots to Git.

Also, how we were querying for specific elements had to be updated. We started
to specify components based on labels or placeholders, which is more stable than
using CSS classes or test IDs. That way if a component class is changed in the
future your tests will not throw a false negative. Changing class names for
styles should not impact tests that are validating behaviors and not styles.
Unfortunately, we continued to use Enzyme for this and made due, but
`react-testing-library` provides these queries as the preferred option for
selecting nodes.

Integration testing as a whole improved due to these changes. We were now
testing different states of components, and how the integration between multiple
components is expected to work from the perspective of the user. The missing
piece now was to test entire workflows in the browser via end-to-end testing.

### End-to-end Testing - Cypress

At this stage, we had rebuilt the platform from the ground-up, and began to add
features, products, and new user roles to the application. The addition of these
made it even more important to have some sort of end-to-end testing. After some
research, it appeared that Cypress was one of the most fully-featured
open-source solutions out there, and there was plenty of community content
surrounding integrating with React and Jenkins.

The first hurdle was handling authentication because you are not able to
navigate away from the URL of the application you are testing. Since we were
using Okta, it required a redirect to a login screen. So, I had to learn how to
make the network request within Cypress, and provide the response data to the
tests. Also, authentication variables are secret, so I made them environment
variables so it would work locally and in the continuous deployment processes.

Then, we needed to write our tests for the most critical workflows so we could
reduce the amount of manual testing on each push. Unfortunately, Cypress
suggests using data attributes to identify the elements you are working with,
which goes against the philosophy of `react-testing-library` that we had
employed elsewhere. But, we made do since this was the preferred method of this
library.

Over the next month, I wrote up tickets for other workflows, and helped other
engineers in applying Cypress to different parts of the project. The end result
was complete coverage for the primary workflows for all of our products, and
ensuring our reporting dashboards were working as expected.

The final step was to include this in our continuous deployment processes. I had
to coordinate with our DevOps Engineer to provide the authentication secrets
from Jenkins in a secure fashion, and to properly execute our npm scripts for
all merges from develop to staging. Lastly, he set up a daily auto-merge
process, since we now had confidence that if it passed our complete test suite
we could merge to staging.

All of this reduced the manual smoke testing we would do for every merge, and
has ensured the stability of the platform as we continued to add new product
workflows to it.

### Styling Architecture - SMACSS + Styled Components

I have always felt comfortable with CSS, and organizing my styles for a project
in a way that makes sense to me. However, this was the first time I was on a
team this large (as many as 8 contributors) where most were not as familiar with
CSS. So, I needed to think of a way to formalize our styling architecture to
avoid styling conflicts, visual regressions, and repetitive styles.

I had heard of styling acronyms like BEM and SMACSS before, but had never
implemented them in practice. After looking into a few of the options, I found
that SMACSS lent itself best to our existing approach and would feel the most
familiar to the rest of the team.

SMACSS stands for Scalable and Modular Architecture for CSS, and it breaks your
styles into five simple categories. Base, layout, module, state, and theme. Base
styles are your global defaults, and layout styles are specific to layout
components like headers, footers, and content sections. Modules represent
components on the page. State takes care of things like errors, active vs.
disabled, and others. Theme is defining your colors and typography.

The `styled-components` library has two features that lent itself to a few of
these categories. The `ThemeProvider` allowed us to provide theme constants to
every styled component in the project automatically, and with TypeScript we
always knew if we were using valid theme properties. Also, the
`createGlobalStyle` function allowed us to provide globally scoped styles to the
project. Right there, Base, State, and Theme were taken care of.

Layout and Modules are basically components, and since styled components scope
their styles to that part of the component tree they handled this part of SMACSS
easily. Each styled component would represent that module or layout style, and
would have access to the theme object to maintain visual consistency.

Making these changes did not require significant onboarding for other team
members since they were already comfortable with styled components, but now we
had a trusted system for maintaining a consistent look and feel through our
global styles and theme properties.

### Back-End Development

Almost everything I have written so far has been in the front-end part of the
stack. A big goal of mine for the past couple of years is to expand from being a
Front-End Software Engineer to a Full-Stack Software Engineer. I know there are
varying opinions on this, but I just want to improve my general ability to build
software at scale and understand the various technologies underpinning modern
business architecture.

I have had a few opportunities to contribute back-end code while at PebblePost.
If I was working on a feature in the front-end and the endpoint I was hitting
was not behaving as expected, I would be able to jump into that project to make
changes then put up two Pull Requests in tandem. In some cases, I was able to
contribute entire features to the back-end, and I was really grateful for that
learning opportunity.

### Spring Boot - Micro-Services Architecture

Our back-end is a Spring Boot application built in a micro-services
architecture. Spring Boot is an opinionated Java-based framework, and I had to
learn concepts like Inversion of Control and Dependency Injection to start to
understand it. Mainly, this means you give up some control to the Spring Boot
framework, and Dependency Injection is merely a pattern to accomplish this.

I was not entirely thrilled with the opinionated nature of this framework, as I
have always been able to view the source code for the libraries I am using in
Javascript-Land. That way I can see what the code I am importing is actually
doing, but for Spring Boot I needed to track down documentation and rely on the
descriptions provided.

### Thread Safety

A mental paradigm shift I had to make was thinking about the context of multiple
threads, and how to write your code in a manner that is "thread safe".
Javascript is a single-threaded language, meaning code is executed in order and
must finish executing before moving on to the next code to execute. Java, on the
other hand, is a multi-threaded language, which is great from a performance
perspective. But, this means your implementation needs to consider this so the
same code produces predictable results in a multiple thread environment.

I was stuck thinking about an application in the context of one user using the
application at the same time. There is one React application hosted somewhere,
but each user accessing it on different devices will have their own internal
state. The back-end is an application that is hosted somewhere, but can be
accessed from multiple "users" concurrently. This means that you need to
consider what values you are tracking in state, and whether that value should be
constant across any number of threads.

Learning this forced me to be more aware of the context in which an application
is being used. Being stuck in the front-end for so long meant I did not have to
consider this before, but I am glad I know about it now!

### PostgreSQL + Database Version Control Systems

We are also using PostgreSQL for our database, and Flyway for keeping track of
changes to the database in Git. This means we commit SQL files to Git, and
Flyway picks up those changes and applies them to the database. Being able to
track the history is much easier this way, and not to mention a lot safer.

I was able to create some new tables for a reporting dashboard we were creating,
and wrote queries for updating certain records as needed. I felt comfortable
with relational databases before this, but learning about version control was
really useful.

## Conclusion

All of these experiences represent a fraction of what I have learned during my
life as a builder of software. Even today, I sometimes feel overwhelmed at the
sheer volume of topics I need to learn to feel I have achieved “mastery” over
this craft. Continuous Integration and Continuous Deployment, Serverless
architecture, GraphQL, NoSQL databases, native mobile applications, and
countless other topics that I would love to learn more about. Each of them takes
time, and I have to realize that it is impossible to master all of them. All I
can do is continue to take my growth one step at a time, and focus on what is in
front of me.

There is a delicate balance between pushing yourself in a sustainable way that
encourages steady progress, and burning yourself out. For the most part, I think
I did okay in that regard. There were a few moments in my career where I felt
lost and tired, and in those moments it took me some time to realize that I
needed to slow myself down. If you are going through something similar, perhaps
it is time to relax, or focus on something else.

Reflecting on these experiences was a great exercise for showing myself some of
the progress that I have made. I hope that reading this has helped you recognize
the progress you have made — in software, or in some other pursuit.
